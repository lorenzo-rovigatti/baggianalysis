# Baggianalysis

Baggianalysis is a library aimed at simplifying the analysis of particle-based simulations. It makes it easy to parse, convert and analyse trajectories generated by simulation codes in an agnostic way. It is written in C++ and provides Python bindings. It is modular and can be extended from C++ and Python.

The following code imports the `baggianalysis` module, parse a single LAMMPS data file, initialises its topology and perform some computations:

	import baggianalysis as ba
	import numpy as np
	import sys
	
	if len(sys.argv) < 2:
	    print("Usage is %s data_file" % sys.argv[0])
	    exit(1)
	
	# initialise a parser for LAMMPS data files with atom_style "bond"
	parser = ba.LAMMPSDataFileParser("bond")
	# parse the system
	system = parser.make_system(sys.argv[1])
	# initialise the topology from the same file
	topology = ba.Topology.make_topology_from_file(sys.argv[1], ba.parse_LAMMPS_topology)
	# apply the topology to the system
	topology.apply(system)
	
	print("Number of molecules: %d" % len(system.molecules()))
	# compute the centres of mass of all the molecules and store them in a list 
	coms = list(map(lambda mol: mol.com(), system.molecules()))
	# print the centres of mass to the "coms.dat" file
	np.savetxt("coms.dat", coms)
	
The library makes it straightforward to work with whole trajectories. Here is an example where we compute the centre of mass of the first molecule of the system averaged over a whole trajectory:

	import baggianalysis as ba
	import numpy as np
	import sys
	
	if len(sys.argv) < 3:
	    print("Usage is %s topology_file dir" % sys.argv[0])
	    exit(1)
		
	parser = ba.LAMMPSDataFileParser("bond")
	trajectory = ba.FullTrajectory(parser)
	# the first parameter is the directory where the trajectory is stored
	# the second parameter is the pattern that will be used to match the filenames
	# the third parameter is True if we want to sort the files, False otherwise 
	trajectory.initialise_from_folder(sys.argv[2], "no_*", True)
	topology = ba.Topology.make_topology_from_file(sys.argv[1], ba.parse_LAMMPS_topology)
	
	com = np.array([0., 0., 0.])
	for system in trajectory.frames:
	    topology.apply(system)
	    com += system.molecules()[0].com()
	    
	print("The average COM is: %lf %lf %lf" % tuple(com / len(trajectory.frames)))
	
Note that baggianalysis provides a [LazyTrajectory](core/trajectories.html#baggianalysis.core.LazyTrajectory) class that parses files one by one to avoid taking up too much memory. This can be useful when dealing with very large trajectories.

```eval_rst
.. toctree::
   :maxdepth: 2
   
   core/core.md
```
